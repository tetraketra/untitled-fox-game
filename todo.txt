[[DATA_STRUCTURES]]
- write `dynamicarray.c`/`dybamicarray.h`
    - implemented as dynmatically sized c-style array
    - should expose var-arg creation syntax
        - e.g. `dyn_array_init(int, 1, 2, 3, 4, 5)` -> {1,2,3,4,5,0,0,0}
    - should expose set/get index which resizes to power of 2 which fits
        - e.g. `{1,2,3,0}`, set(1, 5) -> `{1,5,3,0}`, set(5, 4) -> {1,5,3,0,0,4,0,0,0}
- write bit_array? maybe
    - ** maybe also a specific-length packing system? like "adjacent 5bit numbers" **
    - https://en.wikipedia.org/wiki/Bit_array
    - you can bit shift by casting a series of bits to an int, shifting,
      then comparing to original size's max (e.g. https://stackoverflow.com/questions/8534107/detecting-multiplication-of-uint64-t-integers-overflow-with-c)
    - bit arrays are useful for properties, compression algs, and bloom filters

[[TGL]]
- tgls (tgl state) needs to track `last_keydown_when: time`, `last_keyup_when: time`, and `is_held: bool` for every reasonable key GLFW supports.
    - probably also some form of `was_processed`? Figure out later.
    - in gamedev, "key_move_forward" (or smth like that) references a given tgl keystate, changing where it points to rebind!
    - need a keypress callback which handles this in one giant switch case (X-macro time? If so, define, use, undef, all in function scope). 
   == Definitely use an x-macro-like thing to define all the key structs and the container struct!
- after above (^), implement a way to toggle from any of {windowed, fullscreen, windowed_fullscreen} to any of the same, preserving original window position.
    - will probably need to edit the `*_restore` usages in tgl_callback_window_resize and tgl_callback_window_pos.